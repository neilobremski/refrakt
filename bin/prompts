#!/usr/bin/env python3
"""
prompts — Safe CLI for reading and writing prompts_data.json.

Provides scoped, atomic JSON manipulation for creative agents (lyricist,
producer, title-designer, title-critic) without requiring blanket file
write/edit permissions.

Usage:
    bin/prompts list                              # summary table
    bin/prompts count                             # number of entries
    bin/prompts get <index>                       # full entry as pretty JSON
    bin/prompts get <index> <field>               # single field value
    bin/prompts set <index> <field> <value>       # set a scalar field
    bin/prompts set <index> <field> --stdin       # set from stdin (multi-line)
    bin/prompts set <index> <field> --json <val>  # set a JSON value
    bin/prompts delete <index> <field>            # remove a field
"""

import json
import os
import sys
import tempfile
from pathlib import Path

PROJECT_ROOT = Path(__file__).resolve().parent.parent
PROMPTS_FILE = PROJECT_ROOT / "prompts_data.json"


def load_prompts():
    """Load and return the prompts list from prompts_data.json."""
    if not PROMPTS_FILE.exists():
        print(f"ERROR: {PROMPTS_FILE} not found", file=sys.stderr)
        sys.exit(1)
    try:
        with open(PROMPTS_FILE) as f:
            data = json.load(f)
    except json.JSONDecodeError as e:
        print(f"ERROR: {PROMPTS_FILE} contains invalid JSON: {e}", file=sys.stderr)
        sys.exit(1)
    if not isinstance(data, list):
        print(f"ERROR: {PROMPTS_FILE} root is not a JSON array", file=sys.stderr)
        sys.exit(1)
    return data


def save_prompts(data):
    """Atomically write prompts list back to prompts_data.json."""
    # Write to temp file in same directory, then rename (atomic on same filesystem)
    fd, tmp_path = tempfile.mkstemp(
        dir=PROMPTS_FILE.parent, suffix=".tmp", prefix=".prompts_"
    )
    try:
        with os.fdopen(fd, "w") as f:
            json.dump(data, f, indent=2, ensure_ascii=False)
            f.write("\n")
        os.replace(tmp_path, PROMPTS_FILE)
    except Exception:
        os.unlink(tmp_path)
        raise


def validate_index(prompts, index_str):
    """Parse and validate an index argument. Returns the integer index."""
    try:
        index = int(index_str)
    except ValueError:
        print(f"ERROR: '{index_str}' is not a valid index", file=sys.stderr)
        sys.exit(1)
    if index < 0 or index >= len(prompts):
        print(
            f"ERROR: index {index} out of range (0-{len(prompts) - 1})",
            file=sys.stderr,
        )
        sys.exit(1)
    return index


def cmd_list(prompts):
    """Print a summary table of all entries."""
    if not prompts:
        print("(empty)")
        return
    # Header
    print(f"{'#':<4} {'Title':<28} {'Tags':<6} {'Lyrics':<8} {'Instr':<6} Source")
    print(f"{'─'*4} {'─'*28} {'─'*6} {'─'*8} {'─'*6} {'─'*40}")
    for i, entry in enumerate(prompts):
        title = entry.get("invented_title", "(untitled)")[:27]
        tags_len = f"{len(entry.get('tags', ''))}c"
        prompt_len = f"{len(entry.get('prompt', ''))}c"
        instr = "yes" if entry.get("make_instrumental", False) else "no"
        source_name = entry.get("source_track_name", "?")
        source_artists = ", ".join(entry.get("source_artists", []))
        source = f"{source_name} ({source_artists})" if source_artists else source_name
        print(f"{i:<4} {title:<28} {tags_len:<6} {prompt_len:<8} {instr:<6} {source}")


def cmd_count(prompts):
    """Print the number of entries."""
    print(len(prompts))


def cmd_get(prompts, args):
    """Get a full entry or a single field."""
    if len(args) < 1:
        print("Usage: bin/prompts get <index> [field]", file=sys.stderr)
        sys.exit(1)

    index = validate_index(prompts, args[0])
    entry = prompts[index]

    if len(args) == 1:
        # Full entry
        print(json.dumps(entry, indent=2, ensure_ascii=False))
        return

    field = args[1]
    if field not in entry:
        available = ", ".join(sorted(entry.keys()))
        print(
            f"ERROR: field '{field}' not found in entry {index}. Available: {available}",
            file=sys.stderr,
        )
        sys.exit(1)

    value = entry[field]
    if isinstance(value, str):
        print(value)
    else:
        print(json.dumps(value, indent=2, ensure_ascii=False))


def cmd_set(prompts, args):
    """Set a field on an entry."""
    if len(args) < 2:
        print(
            "Usage: bin/prompts set <index> <field> <value>|--stdin|--json <val>",
            file=sys.stderr,
        )
        sys.exit(1)

    index = validate_index(prompts, args[0])
    field = args[1]
    remaining = args[2:]

    if "--stdin" in remaining:
        value = sys.stdin.read()
    elif "--json" in remaining:
        json_idx = remaining.index("--json")
        if json_idx + 1 >= len(remaining):
            print("ERROR: --json requires a value argument", file=sys.stderr)
            sys.exit(1)
        json_str = remaining[json_idx + 1]
        try:
            value = json.loads(json_str)
        except json.JSONDecodeError as e:
            print(f"ERROR: invalid JSON value: {e}", file=sys.stderr)
            sys.exit(1)
    elif len(remaining) >= 1:
        value = remaining[0]
    else:
        print(
            "ERROR: provide a value, --stdin, or --json <val>", file=sys.stderr
        )
        sys.exit(1)

    prompts[index][field] = value
    save_prompts(prompts)
    # Confirm
    if isinstance(value, str):
        preview = value[:80] + ("..." if len(value) > 80 else "")
        print(f"Set [{index}].{field} = {preview}")
    else:
        print(f"Set [{index}].{field} = {json.dumps(value, ensure_ascii=False)[:80]}")


def cmd_delete(prompts, args):
    """Delete a field from an entry."""
    if len(args) < 2:
        print("Usage: bin/prompts delete <index> <field>", file=sys.stderr)
        sys.exit(1)

    index = validate_index(prompts, args[0])
    field = args[1]

    if field not in prompts[index]:
        print(f"WARN: field '{field}' not found in entry {index} (no-op)", file=sys.stderr)
        return

    del prompts[index][field]
    save_prompts(prompts)
    print(f"Deleted [{index}].{field}")


def main():
    if len(sys.argv) < 2:
        print(__doc__.strip())
        sys.exit(1)

    command = sys.argv[1]
    args = sys.argv[2:]

    if command in ("list", "count"):
        prompts = load_prompts()
        if command == "list":
            cmd_list(prompts)
        else:
            cmd_count(prompts)
    elif command == "get":
        prompts = load_prompts()
        cmd_get(prompts, args)
    elif command == "set":
        prompts = load_prompts()
        cmd_set(prompts, args)
    elif command == "delete":
        prompts = load_prompts()
        cmd_delete(prompts, args)
    else:
        print(f"ERROR: unknown command '{command}'", file=sys.stderr)
        print("Commands: list, count, get, set, delete", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
